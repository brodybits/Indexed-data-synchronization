// Generated by CoffeeScript 1.10.0
(function() {
  var nextTick, root, sampleClientStorage, sampleClientStorageWrapper;

  root = this;

  nextTick = function(cb) {
    return setTimeout(cb, 0);
  };

  sampleClientStorageWrapper = function(state) {
    return {
      addItem: function(record_key, index_values, record_value, callback) {
        state.items[record_key] = {
          index_values: index_values,
          record_value: record_value
        };
        state.addQ.push(record_key);
        nextTick(function() {
          return callback(null);
        });
      },
      deleteItem: function(record_key, callback) {
        var i;
        delete state.items[record_key];
        i = state.addQ.indexOf(record_key);
        if (i === -1) {
          state.deleteQ.push(record_key);
        } else {
          state.addQ.splice(i, 1);
        }
        nextTick(function() {
          return callback(null);
        });
      },
      getItemValue: function(item_key, callback) {
        var i;
        i = state.items[item_key];
        if (i === void 0) {
          nextTick(function() {
            return callback(new Error("Key " + item_key + " not found"));
          });
        } else {
          nextTick(function() {
            return callback(null, i.record_value);
          });
        }
      },
      getItemValuesForIndex: function(index, index_value, callback) {
        var item, itemKey, values;
        values = [];
        for (itemKey in state.items) {
          item = state.items[itemKey];
          if (index < item.index_values.length && item.index_values[index] === index_value) {
            values.push(item.record_value);
          }
        }
        nextTick(function() {
          return callback(null, values);
        });
      },
      syncChangesFromServer: function(changes, callback) {
        var change, j, len;
        if (changes.length === 0) {
          return nextTick(function() {
            return callback(new Error("Cannot sync with zero changes"));
          });
        }
        for (j = 0, len = changes.length; j < len; j++) {
          change = changes[j];
          if (change.change_type === 'DELETE') {
            delete state.items[change.record_key];
          } else {
            if ((state.deleteQ.indexOf(change.record_key)) === -1) {
              state.items[change.record_key] = {
                index_values: change.index_values,
                record_value: change.record_value
              };
            }
          }
        }
        state.after = changes[changes.length - 1].change_id;
        return nextTick(function() {
          return callback(null);
        });
      },
      getSyncState: function(callback) {
        return nextTick(function() {
          return callback(null, {
            addQ: state.addQ,
            deleteQ: state.deleteQ,
            after: state.after
          });
        });
      },
      getChangesToFlush: function(callback) {
        var addkey, changes, deletekey, j, k, len, len1, ref, ref1;
        changes = [];
        ref = state.addQ;
        for (j = 0, len = ref.length; j < len; j++) {
          addkey = ref[j];
          changes.push({
            change_type: 'ADD',
            itemKey: addkey,
            index_values: state.items[addkey].index_values,
            itemValue: state.items[addkey].record_value
          });
        }
        ref1 = state.deleteQ;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          deletekey = ref1[k];
          changes.push({
            change_type: 'DELETE',
            itemKey: deletekey
          });
        }
        return nextTick(function() {
          return callback(null, changes);
        });
      },
      clearAddChangeForKey: function(item_key, callback) {
        var i;
        i = state.addQ.indexOf(item_key);
        if (i !== -1) {
          state.addQ.splice(i, 1);
          return nextTick(function() {
            return callback(null);
          });
        } else {
          return nextTick(function() {
            return callback(new Error("no add change for item key " + itemKey));
          });
        }
      },
      clearDeleteChangeForKey: function(itemKey, callback) {
        var i;
        i = state.deleteQ.indexOf(itemKey);
        if (i !== -1) {
          state.deleteQ.splice(i, 1);
          return nextTick(function() {
            return callback(null);
          });
        } else {
          return nextTick(function() {
            return callback(new Error("no delete change for item key " + itemKey));
          });
        }
      }
    };
  };

  sampleClientStorage = function() {
    return sampleClientStorageWrapper({
      items: {},
      addQ: [],
      deleteQ: [],
      after: 0
    });
  };

  root.sampleClientStorageFacroty = module.exports = {
    sampleClientStorage: sampleClientStorage
  };

}).call(this);
